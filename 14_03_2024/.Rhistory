return(median(x))
}
# Estimate z0 and a0 for sample variance
var_estimates <- bcanon_modified(weibull_samples, sample_variance)
Define a function to calculate bias-corrected and accelerated confidence intervals
# Define a function to calculate bias-corrected and accelerated confidence intervals
bcanon_modified <- function(data, statistic, alpha = 0.05, nboot = 1000) {
# Create an empty vector to store bootstrap statistics
boot_stats <- numeric(nboot)
# Original statistic
original_stat <- statistic(data)
# Bootstrap resampling loop
for (i in 1:nboot) {
# Randomly delete an element from the data
bootstrap_sample <- replicate(nboot, {
bootstrap_sample <- sample(data, replace = TRUE)
})
# Compute the statistic of interest for the bootstrap sample
boot_stats[i] <- statistic(bootstrap_sample)
}
# Compute bias correction and acceleration
z0 <- original_stat - mean(boot_stats)
a <- sum((original_stat - boot_stats) * (original_stat - mean(boot_stats))) /
sum((original_stat - boot_stats)^2)
# Return estimated z0 and a
return(list(z0 = z0, a = a))
}
# Function to compute the sample variance
sample_variance <- function(x) {
return(var(x))
}
# Function to compute the sample median
sample_median <- function(x) {
return(median(x))
}
# Estimate z0 and a0 for sample variance
var_estimates <- bcanon_modified(weibull_samples, sample_variance)
# Define a function to calculate bias-corrected and accelerated confidence intervals
bcanon_modified <- function(data, statistic, alpha = 0.05, nboot = 1000) {
# Create an empty vector to store bootstrap statistics
boot_stats <- numeric(nboot)
# Original statistic
original_stat <- statistic(data)
# Bootstrap resampling loop
for (i in 1:nboot) {
# Randomly delete an element from the data
bootstrap_sample <- sample(data[-sample(length(data), 1)], replace = TRUE)
# Compute the statistic of interest for the bootstrap sample
boot_stats[i] <- statistic(bootstrap_sample)
}
# Compute bias correction and acceleration
z0 <- original_stat - mean(boot_stats)
a <- sum((original_stat - boot_stats) * (original_stat - mean(boot_stats))) /
sum((original_stat - boot_stats)^2)
# Return estimated z0 and a
return(list(z0 = z0, a = a))
}
# Function to compute the sample mean
sample_mean <- function(x) {
return(mean(x))
}
estimates <- bcanon_modified(weibull_samples, sample_mean)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Function to calculate sample variance
calculate_sample_variance <- function(data) {
n <- length(data)
mean_value <- mean(data)
sum_squared_deviations <- sum((data - mean_value)^2)
sample_variance <- sum_squared_deviations / (n - 1)
return(sample_variance)
}
estimates <- bcanon_modified(weibull_samples, calculate_sample_variance)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
sample_median <- function(x) {
return(median(x))
}
estimates <- bcanon_modified(weibull_samples, sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
estimates <- bcanon_modified(weibull_samples,median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
# Estimate z0 and a0
estimates <- bcanon_modified(weibull_samples,sample_median)
z0_estimate <- estimates$z0
a0_estimate <- estimates$a
# Print the estimates
cat("Estimated z0:", z0_estimate, "\n")
cat("Estimated a0:", a0_estimate, "\n")
bcanon_modified <- function(data, statistic, alpha = 0.05, nboot = 1000) {
# Create an empty vector to store bootstrap statistics
boot_stats <- numeric(nboot)
# Original statistic
original_stat <- statistic(data)
# Bootstrap resampling loop
for (i in 1:nboot) {
# Randomly delete an element from the data
bootstrap_sample <- sample(data[-sample(length(data), 1)], replace = TRUE)
# Compute the statistic of interest for the bootstrap sample
boot_stats[i] <- statistic(bootstrap_sample)
}
# Compute bias correction and acceleration
z0 <- original_stat - mean(boot_stats)
a <- sum((original_stat - boot_stats) * (original_stat - mean(boot_stats))) /
sum((original_stat - boot_stats)^2)
# Calculate adjusted confidence interval endpoints
quantiles <- quantile(boot_stats, c(alpha/2, 1 - alpha/2))
z_alpha2 <- qnorm(alpha/2)
z_1_alpha2 <- qnorm(1 - alpha/2)
adjustment <- (z0 + z_alpha2) / (1 - a * z0)
ci_lower <- original_stat + (z0 + adjustment) / (1 - a * z0)
adjustment <- (z0 + z_1_alpha2) / (1 - a * z0)
ci_upper <- original_stat + (z0 + adjustment) / (1 - a * z0)
# Return the confidence interval along with z0 and a
return(list(ci_lower = ci_lower, ci_upper = ci_upper, z0 = z0, a = a))
}
monte_carlo_simulation_bca <- function(M, n, alpha) {
coverage_probability_variance <- numeric(M)
coverage_probability_median <- numeric(M)
avg_length_variance <- numeric(M)
avg_length_median <- numeric(M)
estimated_z0 <- numeric(M)
estimated_a <- numeric(M)
for (i in 1:M) {
# Generate new sample from Weibull distribution
weibull_samples <- rweibull(n, shape = 1, scale = 13)  # Assuming same parameters as original sample
# Bootstrap accelerated bias-corrected (BCa) confidence intervals for variance
ci_variance <- bcanon_modified(weibull_samples, var, alpha = alpha, nboot = n_boot)
ci_median <- bcanon_modified(weibull_samples, median, alpha = alpha, nboot = n_boot)
# Check if true population variance and median are within confidence intervals
true_variance <- var(weibull_samples)
true_median <- median(weibull_samples)
# Coverage probability for variance
coverage_probability_variance[i] <- (true_variance >= ci_variance$ci_lower && true_variance <= ci_variance$ci_upper)
# Coverage probability for median
coverage_probability_median[i] <- (true_median >= ci_median$ci_lower && true_median <= ci_median$ci_upper)
# Average interval lengths
avg_length_variance[i] <- ci_variance$ci_upper - ci_variance$ci_lower
avg_length_median[i] <- ci_median$ci_upper - ci_median$ci_lower
# Estimated z0 and a
estimated_z0[i] <- ci_variance$z0
estimated_a[i] <- ci_variance$a
}
# Calculate coverage probabilities
coverage_probability_variance <- mean(coverage_probability_variance)
coverage_probability_median <- mean(coverage_probability_median)
# Calculate average interval lengths
avg_length_variance <- mean(avg_length_variance)
avg_length_median <- mean(avg_length_median)
# Calculate average estimated z0 and a
avg_estimated_z0 <- mean(estimated_z0)
avg_estimated_a <- mean(estimated_a)
return(list(
coverage_probability_variance = coverage_probability_variance,
coverage_probability_median = coverage_probability_median,
avg_length_variance = avg_length_variance,
avg_length_median = avg_length_median,
avg_estimated_z0 = avg_estimated_z0,
avg_estimated_a = avg_estimated_a
))
}
alpha <- 0.05  # Significance level
# Perform Monte Carlo simulation with BCa confidence intervals
results_bca <- monte_carlo_simulation_bca(1000, 100, alpha)
# Create a data frame to store the results
results_df_total <- data.frame(
Simulation = c("1000 bootstrap replicate of size 100", "1000 bootstrap replicate of size 1000", "5000 bootstrap replicate of size 100", "Bias-corrected confidence intervals"),
Cov_Prob_Variance = c(results$coverage_probability_variance, results1$coverage_probability_variance, results2$coverage_probability_variance, results_bca$coverage_probability_variance),
Cov_Prob_Median = c(results$coverage_probability_median, results1$coverage_probability_median, results2$coverage_probability_median, results_bca$coverage_probability_median),
Avg_Int_Length_Variance = c(results$avg_length_variance, results1$avg_length_variance, results2$avg_length_variance, results_bca$avg_length_variance),
Avg_Int_Length_Median = c(results$avg_length_median, results1$avg_length_median, results2$avg_length_median, results_bca$avg_length_median),
Avg_Estimated_z0 = c(NA, NA, NA, results_bca$avg_estimated_z0),
Avg_Estimated_a = c(NA, NA, NA, results_bca$avg_estimated_a)
)
set.seed(123)  # Set seed for reproducibility
# Parameters
n <- 100  # Number of samples
lambda <- 13  # Scale parameter for Weibull distribution
k <- 1  # Shape parameter for Weibull distribution
# Generate samples from the Weibull distribution
weibull_samples <- rweibull(n, shape = k, scale = lambda)
library(boot)
# Set the number of bootstrap iterations
n_boot <- 1000
# Function to calculate sample variance
calculate_sample_variance <- function(data) {
n <- length(data)
mean_value <- mean(data)
sum_squared_deviations <- sum((data - mean_value)^2)
sample_variance <- sum_squared_deviations / (n - 1)
return(sample_variance)
}
# Perform bootstrap resampling to estimate variances
bootstrapped_variances <- replicate(n_boot, {
bootstrap_sample <- sample(weibull_samples, replace = TRUE)
calculate_sample_variance(bootstrap_sample)
})
# Sort the bootstrapped variances
sorted_variances <- sort(bootstrapped_variances)
# Calculate confidence interval bounds for variance
lower_bound <- quantile(sorted_variances, 0.025)
upper_bound <- quantile(sorted_variances, 0.975)
# Perform bootstrap resampling to estimate medians
bootstrapped_medians <- replicate(n_boot, {
median(sample(weibull_samples, replace = TRUE))
})
# Sort the bootstrapped medians
sorted_medians <- sort(bootstrapped_medians)
# Calculate confidence interval bounds for median
lower_bound_median <- quantile(sorted_medians, 0.025)
upper_bound_median <- quantile(sorted_medians, 0.975)
# Set parameters for Monte Carlo simulation
M <- 1000  # Number of Monte Carlo samples
# Function to perform Monte Carlo simulation
monte_carlo_simulation <- function(M, n) {
# Initialize vectors to store results
coverage_variance <- numeric(M)
coverage_median <- numeric(M)
interval_length_variance <- numeric(M)
interval_length_median <- numeric(M)
for (i in 1:M) {
# Bootstrap resampling for variance confidence interval
bootstrapped_variances <- replicate(n_boot, {
bootstrap_sample <- sample(weibull_samples, replace = TRUE)
calculate_sample_variance(bootstrap_sample)
})
sorted_variances <- sort(bootstrapped_variances)
lower_bound_variance <- quantile(sorted_variances, 0.025)
upper_bound_variance <- quantile(sorted_variances, 0.975)
# Bootstrap resampling for median confidence interval
bootstrapped_medians <- replicate(n_boot, {
median(sample(weibull_samples, replace = TRUE))
})
sorted_medians <- sort(bootstrapped_medians)
lower_bound_median <- quantile(sorted_medians, 0.025)
upper_bound_median <- quantile(sorted_medians, 0.975)
# Check if true population variance and median are within confidence intervals
true_variance <- var(weibull_samples)
true_median <- median(weibull_samples)
coverage_variance[i] <- (true_variance >= lower_bound_variance && true_variance <= upper_bound_variance)
coverage_median[i] <- (true_median >= lower_bound_median && true_median <= upper_bound_median)
# Calculate interval lengths
interval_length_variance[i] <- upper_bound_variance - lower_bound_variance
interval_length_median[i] <- upper_bound_median - lower_bound_median
}
# Calculate coverage probabilities
coverage_probability_variance <- mean(coverage_variance)
coverage_probability_median <- mean(coverage_median)
# Calculate average interval lengths
avg_length_variance <- mean(interval_length_variance)
avg_length_median <- mean(interval_length_median)
return(list(
coverage_probability_variance = coverage_probability_variance,
coverage_probability_median = coverage_probability_median,
avg_length_variance = avg_length_variance,
avg_length_median = avg_length_median
))
}
# Perform Monte Carlo simulation
results <- monte_carlo_simulation(M, n)
# Perform additional simulations with different parameters
results1 <- monte_carlo_simulation(1000, 1000)
results2 <- monte_carlo_simulation(5000, 100)
# Create a data frame to store the results
results_df <- data.frame(
Simulation = c("1000 bootstrap replicate of size 100", "1000 bootstrap replicate of size 1000", "5000 bootstrap replicate of size 100","Bias-corrected confidence intervals"),
Cov_Prob_Variance = c(results$coverage_probability_variance, results1$coverage_probability_variance, results2$coverage_probability_variance),
Cov_Prob_Median = c(results$coverage_probability_median,     results1$coverage_probability_median,   results2$coverage_probability_median),
Avg_Int_Length_Variance = c(results$avg_length_variance,     results1$avg_length_variance,           results2$avg_length_variance),
Avg_Int_Length_Median = c(results$avg_length_median,         results1$avg_length_median,             results2$avg_length_median)
)
# Create a data frame to store the results
results_df_total <- data.frame(
Simulation = c("1000 bootstrap replicate of size 100", "1000 bootstrap replicate of size 1000", "5000 bootstrap replicate of size 100", "Bias-corrected confidence intervals"),
Cov_Prob_Variance = c(results$coverage_probability_variance, results1$coverage_probability_variance, results2$coverage_probability_variance, results_bca$coverage_probability_variance),
Cov_Prob_Median = c(results$coverage_probability_median, results1$coverage_probability_median, results2$coverage_probability_median, results_bca$coverage_probability_median),
Avg_Int_Length_Variance = c(results$avg_length_variance, results1$avg_length_variance, results2$avg_length_variance, results_bca$avg_length_variance),
Avg_Int_Length_Median = c(results$avg_length_median, results1$avg_length_median, results2$avg_length_median, results_bca$avg_length_median),
Estimated_z0 = c(NA, NA, NA, results_bca$avg_estimated_z0),
Estimated_a = c(NA, NA, NA, results_bca$avg_estimated_a)
)
View(results_df_total)
# Export the data frame as a CSV file
write.csv(results_df_total, "results_table_for_whole_Part(A).csv", row.names = FALSE)
set.seed(123)  # Set seed for reproducibility
# Parameters
n <- 100  # Number of samples
lambda <- 13  # Scale parameter for Weibull distribution
k <- 1  # Shape parameter for Weibull distribution
# Generate samples from the Weibull distribution
weibull_samples <- rweibull(n, shape = k, scale = lambda)
library(boot)
# Set the number of bootstrap iterations
n_boot <- 1000
# Function to calculate sample variance
calculate_sample_variance <- function(data) {
n <- length(data)
mean_value <- mean(data)
sum_squared_deviations <- sum((data - mean_value)^2)
sample_variance <- sum_squared_deviations / (n - 1)
return(sample_variance)
}
# Perform bootstrap resampling to estimate variances
bootstrapped_variances <- replicate(n_boot, {
bootstrap_sample <- sample(weibull_samples, replace = TRUE)
calculate_sample_variance(bootstrap_sample)
})
# Sort the bootstrapped variances
sorted_variances <- sort(bootstrapped_variances)
# Calculate confidence interval bounds for variance
lower_bound <- quantile(sorted_variances, 0.025)
upper_bound <- quantile(sorted_variances, 0.975)
# Perform bootstrap resampling to estimate medians
bootstrapped_medians <- replicate(n_boot, {
median(sample(weibull_samples, replace = TRUE))
})
# Sort the bootstrapped medians
sorted_medians <- sort(bootstrapped_medians)
# Calculate confidence interval bounds for median
lower_bound_median <- quantile(sorted_medians, 0.025)
upper_bound_median <- quantile(sorted_medians, 0.975)
# Set parameters for Monte Carlo simulation
M <- 1000  # Number of Monte Carlo samples
# Function to perform Monte Carlo simulation
monte_carlo_simulation <- function(M, n) {
# Initialize vectors to store results
coverage_variance <- numeric(M)
coverage_median <- numeric(M)
interval_length_variance <- numeric(M)
interval_length_median <- numeric(M)
for (i in 1:M) {
# Bootstrap resampling for variance confidence interval
bootstrapped_variances <- replicate(n_boot, {
bootstrap_sample <- sample(weibull_samples, replace = TRUE)
calculate_sample_variance(bootstrap_sample)
})
sorted_variances <- sort(bootstrapped_variances)
lower_bound_variance <- quantile(sorted_variances, 0.025)
upper_bound_variance <- quantile(sorted_variances, 0.975)
# Bootstrap resampling for median confidence interval
bootstrapped_medians <- replicate(n_boot, {
median(sample(weibull_samples, replace = TRUE))
})
sorted_medians <- sort(bootstrapped_medians)
lower_bound_median <- quantile(sorted_medians, 0.025)
upper_bound_median <- quantile(sorted_medians, 0.975)
# Check if true population variance and median are within confidence intervals
true_variance <- var(weibull_samples)
true_median <- median(weibull_samples)
coverage_variance[i] <- (true_variance >= lower_bound_variance && true_variance <= upper_bound_variance)
coverage_median[i] <- (true_median >= lower_bound_median && true_median <= upper_bound_median)
# Calculate interval lengths
interval_length_variance[i] <- upper_bound_variance - lower_bound_variance
interval_length_median[i] <- upper_bound_median - lower_bound_median
}
# Calculate coverage probabilities
coverage_probability_variance <- mean(coverage_variance)
coverage_probability_median <- mean(coverage_median)
# Calculate average interval lengths
avg_length_variance <- mean(interval_length_variance)
avg_length_median <- mean(interval_length_median)
return(list(
coverage_probability_variance = coverage_probability_variance,
coverage_probability_median = coverage_probability_median,
avg_length_variance = avg_length_variance,
avg_length_median = avg_length_median
))
}
# Perform Monte Carlo simulation
results <- monte_carlo_simulation(M, n)
# Perform additional simulations with different parameters
results1 <- monte_carlo_simulation(1000, 1000)
results2 <- monte_carlo_simulation(5000, 100)
library(bootstrap)
set.seed(123)
bcanon_modified <- function(data, statistic, alpha = 0.05, nboot = 1000) {
# Create an empty vector to store bootstrap statistics
boot_stats <- numeric(nboot)
# Original statistic
original_stat <- statistic(data)
# Bootstrap resampling loop
for (i in 1:nboot) {
# Randomly delete an element from the data
bootstrap_sample <- sample(data[-sample(length(data), 1)], replace = TRUE)
# Compute the statistic of interest for the bootstrap sample
boot_stats[i] <- statistic(bootstrap_sample)
}
# Compute bias correction and acceleration
z0 <- original_stat - mean(boot_stats)
a <- sum((original_stat - boot_stats) * (original_stat - mean(boot_stats))) /
sum((original_stat - boot_stats)^2)
# Calculate adjusted confidence interval endpoints
quantiles <- quantile(boot_stats, c(alpha/2, 1 - alpha/2))
z_alpha2 <- qnorm(alpha/2)
z_1_alpha2 <- qnorm(1 - alpha/2)
adjustment <- (z0 + z_alpha2) / (1 - a * z0)
ci_lower <- original_stat + (z0 + adjustment) / (1 - a * z0)
adjustment <- (z0 + z_1_alpha2) / (1 - a * z0)
ci_upper <- original_stat + (z0 + adjustment) / (1 - a * z0)
# Return the confidence interval along with z0 and a
return(list(ci_lower = ci_lower, ci_upper = ci_upper, z0 = z0, a = a))
}
monte_carlo_simulation_bca <- function(M, n, alpha) {
coverage_probability_variance <- numeric(M)
coverage_probability_median <- numeric(M)
avg_length_variance <- numeric(M)
avg_length_median <- numeric(M)
estimated_z0 <- numeric(M)
estimated_a <- numeric(M)
for (i in 1:M) {
# Generate new sample from Weibull distribution
weibull_samples <- rweibull(n, shape = 1, scale = 13)  # Assuming same parameters as original sample
# Bootstrap accelerated bias-corrected (BCa) confidence intervals for variance
ci_variance <- bcanon_modified(weibull_samples, var, alpha = alpha, nboot = n_boot)
ci_median <- bcanon_modified(weibull_samples, median, alpha = alpha, nboot = n_boot)
# Check if true population variance and median are within confidence intervals
true_variance <- var(weibull_samples)
true_median <- median(weibull_samples)
# Coverage probability for variance
coverage_probability_variance[i] <- (true_variance >= ci_variance$ci_lower && true_variance <= ci_variance$ci_upper)
# Coverage probability for median
coverage_probability_median[i] <- (true_median >= ci_median$ci_lower && true_median <= ci_median$ci_upper)
# Average interval lengths
avg_length_variance[i] <- ci_variance$ci_upper - ci_variance$ci_lower
avg_length_median[i] <- ci_median$ci_upper - ci_median$ci_lower
# Estimated z0 and a
estimated_z0[i] <- ci_variance$z0
estimated_a[i] <- ci_variance$a
}
# Calculate coverage probabilities
coverage_probability_variance <- mean(coverage_probability_variance)
coverage_probability_median <- mean(coverage_probability_median)
# Calculate average interval lengths
avg_length_variance <- mean(avg_length_variance)
avg_length_median <- mean(avg_length_median)
# Calculate average estimated z0 and a
avg_estimated_z0 <- mean(estimated_z0)
avg_estimated_a <- mean(estimated_a)
return(list(
coverage_probability_variance = coverage_probability_variance,
coverage_probability_median = coverage_probability_median,
avg_length_variance = avg_length_variance,
avg_length_median = avg_length_median,
avg_estimated_z0 = avg_estimated_z0,
avg_estimated_a = avg_estimated_a
))
}
alpha <- 0.05  # Significance level
# Perform Monte Carlo simulation with BCa confidence intervals
results_bca <- monte_carlo_simulation_bca(1000, 100, alpha)
# Create a data frame to store the results
results_df_total <- data.frame(
Simulation = c("1000 bootstrap replicate of size 100", "1000 bootstrap replicate of size 1000", "5000 bootstrap replicate of size 100", "Bias-corrected confidence intervals"),
Cov_Prob_Variance = c(results$coverage_probability_variance, results1$coverage_probability_variance, results2$coverage_probability_variance, results_bca$coverage_probability_variance),
Cov_Prob_Median = c(results$coverage_probability_median, results1$coverage_probability_median, results2$coverage_probability_median, results_bca$coverage_probability_median),
Avg_Int_Length_Variance = c(results$avg_length_variance, results1$avg_length_variance, results2$avg_length_variance, results_bca$avg_length_variance),
Avg_Int_Length_Median = c(results$avg_length_median, results1$avg_length_median, results2$avg_length_median, results_bca$avg_length_median),
Estimated_z0 = c(NA, NA, NA, results_bca$avg_estimated_z0),
Estimated_a = c(NA, NA, NA, results_bca$avg_estimated_a)
)
# Export the data frame as a CSV file
write.csv(results_df_total, "results_table_for_whole_Part(A).csv", row.names = FALSE)
View(results_df_total)
